import*as e from"stream";var r="default"in e?e.default:e;var t={};var n=r;function DuplexWrapper(e,r,t){if("undefined"===typeof t){t=r;r=e;e=null}n.Duplex.call(this,e);"function"!==typeof t.read&&(t=new n.Readable(e).wrap(t));this._writable=r;this._readable=t;this._waiting=false;var a=this;r.once("finish",(function(){a.end()}));this.once("finish",(function(){r.end()}));t.on("readable",(function(){if(a._waiting){a._waiting=false;a._read()}}));t.once("end",(function(){a.push(null)}));if(!e||"undefined"===typeof e.bubbleErrors||e.bubbleErrors){r.on("error",(function(e){a.emit("error",e)}));t.on("error",(function(e){a.emit("error",e)}))}}DuplexWrapper.prototype=Object.create(n.Duplex.prototype,{constructor:{value:DuplexWrapper}});DuplexWrapper.prototype._write=function _write(e,r,t){this._writable.write(e,r,t)};DuplexWrapper.prototype._read=function _read(){var e;var r=0;while(null!==(e=this._readable.read())){this.push(e);r++}0===r&&(this._waiting=true)};t=function duplex2(e,r,t){return new DuplexWrapper(e,r,t)};t.DuplexWrapper=DuplexWrapper;var a=t;const p=t.DuplexWrapper;export{p as DuplexWrapper,a as default};

