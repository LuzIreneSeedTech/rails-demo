import e from"p-timeout";var t={};const o=e;const n=Symbol.asyncIterator||"@@asyncIterator";const normalizeEmitter=e=>{const t=e.on||e.addListener||e.addEventListener;const o=e.off||e.removeListener||e.removeEventListener;if(!t||!o)throw new TypeError("Emitter is not compatible");return{addListener:t.bind(e),removeListener:o.bind(e)}};const normalizeEvents=e=>Array.isArray(e)?e:[e];const multiple=(e,t,n)=>{let r;const s=new Promise((o,s)=>{n=Object.assign({rejectionEvents:["error"],multiArgs:false,resolveImmediately:false},n);if(!(n.count>=0&&(Infinity===n.count||Number.isInteger(n.count))))throw new TypeError("The `count` option should be at least 0 or more");const i=normalizeEvents(t);const l=[];const{addListener:c,removeListener:f}=normalizeEmitter(e);const onItem=(...e)=>{const t=n.multiArgs?e:e[0];if(!n.filter||n.filter(t)){l.push(t);if(n.count===l.length){r();o(l)}}};const rejectHandler=e=>{r();s(e)};r=()=>{for(const e of i)f(e,onItem);for(const e of n.rejectionEvents)f(e,rejectHandler)};for(const e of i)c(e,onItem);for(const e of n.rejectionEvents)c(e,rejectHandler);n.resolveImmediately&&o(l)});s.cancel=r;if("number"===typeof n.timeout){const e=o(s,n.timeout);e.cancel=r;return e}return s};t=(e,t,o)=>{"function"===typeof o&&(o={filter:o});o=Object.assign({},o,{count:1,resolveImmediately:false});const n=multiple(e,t,o);const r=n.then(e=>e[0]);r.cancel=n.cancel;return r};t.multiple=multiple;t.iterator=(e,t,o)=>{"function"===typeof o&&(o={filter:o});const r=normalizeEvents(t);o=Object.assign({rejectionEvents:["error"],resolutionEvents:[],limit:Infinity,multiArgs:false},o);const{limit:s}=o;const i=s>=0&&(Infinity===s||Number.isInteger(s));if(!i)throw new TypeError("The `limit` option should be a non-negative integer or Infinity");if(0===s)return{[Symbol.asyncIterator](){return this},next(){return Promise.resolve({done:true,value:void 0})}};let l=false;const{addListener:c,removeListener:f}=normalizeEmitter(e);let u=false;let a;let m=false;const v=[];const d=[];let h=0;const valueHandler=(...e)=>{h++;l=h===s;const t=o.multiArgs?e:e[0];if(v.length>0){const{resolve:e}=v.shift();e({done:false,value:t});l&&cancel()}else{d.push(t);l&&cancel()}};const cancel=()=>{u=true;for(const e of r)f(e,valueHandler);for(const e of o.rejectionEvents)f(e,rejectHandler);for(const e of o.resolutionEvents)f(e,resolveHandler);while(v.length>0){const{resolve:e}=v.shift();e({done:true,value:void 0})}};const rejectHandler=(...e)=>{a=o.multiArgs?e:e[0];if(v.length>0){const{reject:e}=v.shift();e(a)}else m=true;cancel()};const resolveHandler=(...e)=>{const t=o.multiArgs?e:e[0];if(!o.filter||o.filter(t)){if(v.length>0){const{resolve:e}=v.shift();e({done:true,value:t})}else d.push(t);cancel()}};for(const e of r)c(e,valueHandler);for(const e of o.rejectionEvents)c(e,rejectHandler);for(const e of o.resolutionEvents)c(e,resolveHandler);return{[n](){return this},next(){if(d.length>0){const e=d.shift();return Promise.resolve({done:u&&0===d.length&&!l,value:e})}if(m){m=false;return Promise.reject(a)}return u?Promise.resolve({done:true,value:void 0}):new Promise((e,t)=>v.push({resolve:e,reject:t}))},return(e){cancel();return Promise.resolve({done:u,value:e})}}};var r=t;const s=t.iterator;const i=t.multiple;export default r;export{s as iterator,i as multiple};

