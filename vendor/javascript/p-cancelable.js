var e={};class CancelError extends Error{constructor(){super("Promise was canceled");this.name="CancelError"}get isCanceled(){return true}}class PCancelable{static fn(e){return function(){const r=[].slice.apply(arguments);return new PCancelable((t,n,s)=>{r.push(s);e.apply(null,r).then(t,n)})}}constructor(e){this._cancelHandlers=[];this._isPending=true;this._isCanceled=false;this._promise=new Promise((r,t)=>{this._reject=t;return e(e=>{this._isPending=false;r(e)},e=>{this._isPending=false;t(e)},e=>{this._cancelHandlers.push(e)})})}then(e,r){return this._promise.then(e,r)}catch(e){return this._promise.catch(e)}finally(e){return this._promise.finally(e)}cancel(){if(this._isPending&&!this._isCanceled){if(this._cancelHandlers.length>0)try{for(const e of this._cancelHandlers)e()}catch(e){this._reject(e)}this._isCanceled=true;this._reject(new CancelError)}}get isCanceled(){return this._isCanceled}}Object.setPrototypeOf(PCancelable.prototype,Promise.prototype);e=PCancelable;e.CancelError=CancelError;var r=e;const t=e.CancelError;export default r;export{t as CancelError};

